// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/sevigo/code-warden/internal/storage (interfaces: ScopedVectorStore)
//
// Generated by this command:
//
//	mockgen -destination=mocks/mock_scoped_vectorstore.go -package=mocks github.com/sevigo/code-warden/internal/storage ScopedVectorStore
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	schema "github.com/sevigo/goframe/schema"
	vectorstores "github.com/sevigo/goframe/vectorstores"
	gomock "go.uber.org/mock/gomock"
)

// MockScopedVectorStore is a mock of ScopedVectorStore interface.
type MockScopedVectorStore struct {
	ctrl     *gomock.Controller
	recorder *MockScopedVectorStoreMockRecorder
	isgomock struct{}
}

// MockScopedVectorStoreMockRecorder is the mock recorder for MockScopedVectorStore.
type MockScopedVectorStoreMockRecorder struct {
	mock *MockScopedVectorStore
}

// NewMockScopedVectorStore creates a new mock instance.
func NewMockScopedVectorStore(ctrl *gomock.Controller) *MockScopedVectorStore {
	mock := &MockScopedVectorStore{ctrl: ctrl}
	mock.recorder = &MockScopedVectorStoreMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockScopedVectorStore) EXPECT() *MockScopedVectorStoreMockRecorder {
	return m.recorder
}

// AddDocuments mocks base method.
func (m *MockScopedVectorStore) AddDocuments(ctx context.Context, docs []schema.Document, options ...vectorstores.Option) ([]string, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, docs}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AddDocuments", varargs...)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// AddDocuments indicates an expected call of AddDocuments.
func (mr *MockScopedVectorStoreMockRecorder) AddDocuments(ctx, docs any, options ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, docs}, options...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddDocuments", reflect.TypeOf((*MockScopedVectorStore)(nil).AddDocuments), varargs...)
}

// CollectionName mocks base method.
func (m *MockScopedVectorStore) CollectionName() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CollectionName")
	ret0, _ := ret[0].(string)
	return ret0
}

// CollectionName indicates an expected call of CollectionName.
func (mr *MockScopedVectorStoreMockRecorder) CollectionName() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CollectionName", reflect.TypeOf((*MockScopedVectorStore)(nil).CollectionName))
}

// DeleteCollection mocks base method.
func (m *MockScopedVectorStore) DeleteCollection(ctx context.Context, collectionName string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteCollection", ctx, collectionName)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteCollection indicates an expected call of DeleteCollection.
func (mr *MockScopedVectorStoreMockRecorder) DeleteCollection(ctx, collectionName any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteCollection", reflect.TypeOf((*MockScopedVectorStore)(nil).DeleteCollection), ctx, collectionName)
}

// DeleteDocumentsByFilter mocks base method.
func (m *MockScopedVectorStore) DeleteDocumentsByFilter(ctx context.Context, filters map[string]any, options ...vectorstores.Option) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, filters}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteDocumentsByFilter", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteDocumentsByFilter indicates an expected call of DeleteDocumentsByFilter.
func (mr *MockScopedVectorStoreMockRecorder) DeleteDocumentsByFilter(ctx, filters any, options ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, filters}, options...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteDocumentsByFilter", reflect.TypeOf((*MockScopedVectorStore)(nil).DeleteDocumentsByFilter), varargs...)
}

// EmbedderModel mocks base method.
func (m *MockScopedVectorStore) EmbedderModel() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "EmbedderModel")
	ret0, _ := ret[0].(string)
	return ret0
}

// EmbedderModel indicates an expected call of EmbedderModel.
func (mr *MockScopedVectorStoreMockRecorder) EmbedderModel() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EmbedderModel", reflect.TypeOf((*MockScopedVectorStore)(nil).EmbedderModel))
}

// ListCollections mocks base method.
func (m *MockScopedVectorStore) ListCollections(ctx context.Context) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListCollections", ctx)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListCollections indicates an expected call of ListCollections.
func (mr *MockScopedVectorStoreMockRecorder) ListCollections(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListCollections", reflect.TypeOf((*MockScopedVectorStore)(nil).ListCollections), ctx)
}

// SimilaritySearch mocks base method.
func (m *MockScopedVectorStore) SimilaritySearch(ctx context.Context, query string, numDocuments int, options ...vectorstores.Option) ([]schema.Document, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, query, numDocuments}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SimilaritySearch", varargs...)
	ret0, _ := ret[0].([]schema.Document)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SimilaritySearch indicates an expected call of SimilaritySearch.
func (mr *MockScopedVectorStoreMockRecorder) SimilaritySearch(ctx, query, numDocuments any, options ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, query, numDocuments}, options...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SimilaritySearch", reflect.TypeOf((*MockScopedVectorStore)(nil).SimilaritySearch), varargs...)
}

// SimilaritySearchBatch mocks base method.
func (m *MockScopedVectorStore) SimilaritySearchBatch(ctx context.Context, queries []string, numDocuments int, options ...vectorstores.Option) ([][]schema.Document, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, queries, numDocuments}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SimilaritySearchBatch", varargs...)
	ret0, _ := ret[0].([][]schema.Document)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SimilaritySearchBatch indicates an expected call of SimilaritySearchBatch.
func (mr *MockScopedVectorStoreMockRecorder) SimilaritySearchBatch(ctx, queries, numDocuments any, options ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, queries, numDocuments}, options...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SimilaritySearchBatch", reflect.TypeOf((*MockScopedVectorStore)(nil).SimilaritySearchBatch), varargs...)
}

// SimilaritySearchWithScores mocks base method.
func (m *MockScopedVectorStore) SimilaritySearchWithScores(ctx context.Context, query string, numDocuments int, options ...vectorstores.Option) ([]vectorstores.DocumentWithScore, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, query, numDocuments}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SimilaritySearchWithScores", varargs...)
	ret0, _ := ret[0].([]vectorstores.DocumentWithScore)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SimilaritySearchWithScores indicates an expected call of SimilaritySearchWithScores.
func (mr *MockScopedVectorStoreMockRecorder) SimilaritySearchWithScores(ctx, query, numDocuments any, options ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, query, numDocuments}, options...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SimilaritySearchWithScores", reflect.TypeOf((*MockScopedVectorStore)(nil).SimilaritySearchWithScores), varargs...)
}
