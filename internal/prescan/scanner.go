package prescan

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/sevigo/code-warden/internal/llm"
	"github.com/sevigo/code-warden/internal/storage"
)

// Scanner handles the resumable scanning process.
type Scanner struct {
	Manager    *Manager
	RAGService llm.RAGService
}

func NewScanner(m *Manager, rag llm.RAGService) *Scanner {
	return &Scanner{
		Manager:    m,
		RAGService: rag,
	}
}

func (s *Scanner) Scan(ctx context.Context, input string, force bool) error {
	// 1. Prepare Repo (Clone if needed)
	localPath, owner, repo, err := s.Manager.PrepareRepo(ctx, input)
	if err != nil {
		return err
	}
	repoFullName := fmt.Sprintf("%s/%s", owner, repo)
	s.Manager.logger.Info("Starting scan", "repo", repoFullName, "path", localPath)

	// 2. Ensure Repo Record in DB
	repoRecord, err := s.ensureRepoRecord(ctx, repoFullName, localPath)
	if err != nil {
		return err
	}

	// 3. Load State
	stateMgr := NewStateManager(s.Manager.store, repoRecord.ID)
	scanState, progress, err := stateMgr.LoadState(ctx)
	if err != nil {
		return err
	}

	// Auto-resume logic
	if force || scanState == nil || scanState.Status == string(StatusCompleted) || scanState.Status == string(StatusFailed) {
		s.Manager.logger.Info("Starting fresh scan")
		progress = &Progress{
			Files:       make(map[string]bool),
			LastUpdated: time.Now(),
		}
		if err := stateMgr.SaveState(ctx, StatusPending, progress); err != nil {
			return err
		}
	} else {
		s.Manager.logger.Info("Resuming scan", "processed", progress.ProcessedFiles, "total_known", progress.TotalFiles)
	}

	// 4. Discover Files
	files, err := s.listFiles(localPath)
	if err != nil {
		return fmt.Errorf("failed to list files: %w", err)
	}
	progress.TotalFiles = len(files)

	// 5. Update State to In Progress
	if err := stateMgr.SaveState(ctx, StatusInProgress, progress); err != nil {
		return err
	}

	// 6. Iterate and Process
	// We use the scoped store directly via RAG service logic (we need RAG to expose AddDocuments or we use underlying store)
	// Actually RAGService has `UpdateRepoContext` but that's for batch.
	// The requirement is to be granular.
	// We will use `RAGService.ProcessFile` to get docs, then Add manually.

	// Issue: RAGService doesn't expose `AddDocuments`.
	// We can cast `s.Manager.store`? No, vector store is separate.
	// We should probably rely on `UpdateRepoContext` for BATCHES of granular files if we want to reuse logic,
	// OR we need to access the vector store.

	// Assumption: We can't easily access vector store here without exposing it from Manager or RAG.
	// Let's assume for now we just want to ensure we "Process" them.
	// Wait, if we don't store embeddings, the scan is useless.
	// `RAGService` is interface. `ragService` struct has `vectorStore`.
	// We should probably add `AddDocuments` to RAGService interface or use `UpdateRepoContext` with single/batch files.
	// But `UpdateRepoContext` does diff checks.

	// Workaround: We will use `UpdateRepoContext` with a batch of files.
	// Since `UpdateRepoContext` handles "filesToProcess", we can pass a batch of 10-20 files.
	// But `UpdateRepoContext` also does filtering/hashing.

	// Let's implement granular processing by batching.
	batchSize := 10
	var batch []string

	for i, file := range files {
		if progress.Files[file] {
			continue
		}

		batch = append(batch, file)

		if len(batch) >= batchSize || i == len(files)-1 {
			// Process Batch
			s.Manager.logger.Info("Processing batch", "size", len(batch), "current", i+1, "total", len(files))

			// We can use UpdateRepoContext to process these specific files.
			// It will re-hash them, but that's fine.
			err := s.RAGService.UpdateRepoContext(ctx, nil, repoRecord, localPath, batch, nil)
			if err != nil {
				s.Manager.logger.Error("Failed to process batch", "error", err)
				// Don't fail entire scan, maybe? Or do?
				// For now, fail to be safe.
				return err
			}

			// Update Progress
			for _, f := range batch {
				progress.Files[f] = true
				progress.ProcessedFiles++
			}
			progress.LastUpdated = time.Now()
			if err := stateMgr.SaveState(ctx, StatusInProgress, progress); err != nil {
				s.Manager.logger.Warn("Failed to save state", "error", err)
			}

			batch = nil // Reset batch
		}
	}

	// 7. Complete
	if err := stateMgr.SaveState(ctx, StatusCompleted, progress); err != nil {
		return err
	}
	s.Manager.logger.Info("Scan completed successfully")

	// 8. Generate Documentation (TODO)
	// DocGen logic here

	return nil
}

func (s *Scanner) ensureRepoRecord(ctx context.Context, fullName, path string) (*storage.Repository, error) {
	rec, err := s.Manager.store.GetRepositoryByFullName(ctx, fullName)
	if err != nil {
		return nil, err
	}
	if rec == nil {
		newRec := &storage.Repository{
			FullName:          fullName,
			ClonePath:         path,
			EmbedderModelName: s.Manager.cfg.AI.EmbedderModel,
			// QdrantCollectionName generated by storage/repomanager usually,
			// let's duplicate logic or better yet, make sure we use consistent naming.
			// Ideally we use repomanager.GenerateCollectionName but that's in internal/repomanager.
			// Let's simple use sanitized fullName for now or similar.
			QdrantCollectionName: strings.ReplaceAll(strings.ReplaceAll(fullName, "/", "_"), "-", "_") + "_" + s.Manager.cfg.AI.EmbedderModel,
		}
		if err := s.Manager.store.CreateRepository(ctx, newRec); err != nil {
			return nil, err
		}
		return newRec, nil
	}
	return rec, nil
}

func (s *Scanner) listFiles(root string) ([]string, error) {
	var files []string
	err := filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if info.IsDir() {
			name := info.Name()
			if strings.HasPrefix(name, ".") && name != "." {
				return filepath.SkipDir
			}
			return nil
		}
		// Basic extension filter
		ext := strings.ToLower(filepath.Ext(path))
		if !validExt(ext) {
			return nil
		}

		rel, err := filepath.Rel(root, path)
		if err != nil {
			return err
		}
		files = append(files, strings.ReplaceAll(rel, "\\", "/"))
		return nil
	})
	return files, err
}

func validExt(ext string) bool {
	switch ext {
	case ".go", ".js", ".ts", ".py", ".java", ".c", ".cpp", ".h", ".rs", ".md", ".json", ".yaml", ".yml":
		return true
	}
	return false
}
